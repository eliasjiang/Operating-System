## 缓存管理

在深入研究策略之前，先详细描述一下我们要解决的问题。由于内存只包含系统中所
有页的子集，因此可以将其视为系统中虚拟内存页的缓存（cache）。因此，在为这个缓存选择替换策略时，我们的目标是让缓存未命中（cache  miss）最少，即使得从磁盘获取页的次数最少。或者，可以将目标看成让缓存命中（cache hit）最多，即在内存中找到待访问页的次数最多。

## 最优替换策略
**为了更好地理解一个特定的替换策略是如何工作的，将它与最好的替换策略进行比较是很好的方法。**事实证明，这样一个最优（optimal）策略是Belady 多年前开发的[B66]（原来这个策略叫作MIN）。最优替换策略能达到总体未命中数量最少。Belady 展示了一个简单的方法（但遗憾的是，很难实现！），即替换内存中在最远将来才会被访问到的页，可以达到缓存未命中率最低。

## 简单策略：FIFO

## 另一简单策略：随机

## 利用历史数据：LRU
页替换策略可以使用的一个历史信息是频率（frequency）。如果一个页被访问了很多次，也许它不应该被替换，因为它显然更有价值。页更常用的属性是访问的近期性（recency），越近被访问过的页，也许再次访问的可能性也就越大。

因此，一系列简单的基于历史的算法诞生了。“最不经常使用”（Least-Frequently-Used，
LFU）策略会替换最不经常使用的页。同样，“最少最近使用”（Least-Recently-Used，LRU）
策略替换最近最少使用的页面。

## 近似LRU

## 考虑脏页
时钟算法的一个小修改（最初也由Corbato [C69]提出），是对内存中的页是否被修改的
额外考虑。这样做的原因是：如果页已被修改（modified）并因此变脏（dirty），则踢出它就必须将它写回磁盘，这很昂贵。如果它没有被修改（因此是干净的，clean），踢出就没成本。物理帧可以简单地重用于其他目的而无须额外的I/O。因此，一些虚拟机系统更倾向于踢出干净页，而不是脏页。 

为了支持这种行为，硬件应该包括一个修改位（modified bit，又名脏位，dirty bit）。每次写入页时都会设置此位，因此可以将其合并到页面替换算法中。例如，时钟算法可以被改变，以扫描既未使用又干净的页先踢出。无法找到这种页时，再查找脏的未使用页面，等等。 


## 其他虚拟内存策略
页面替换不是虚拟内存子系统采用的唯一策略（尽管它可能是最重要的）。例如，操作
系统还必须决定何时将页载入内存。该策略有时称为页选择（page  selection）策略（因为Denning 这样命名[D70]），它向操作系统提供了一些不同的选项。

对于大多数页而言，操作系统只是使用按需分页（demand paging），这意味着操作系统
在页被访问时将页载入内存中，“按需”即可。当然，操作系统可能会猜测一个页面即将被
使用，从而提前载入。这种行为被称为预取（prefetching），只有在有合理的成功机会时才应该这样做。例如，一些系统将假设如果代码页P 被载入内存，那么代码页P + 1 很可能很快被访问，因此也应该被载入内存。

另一个策略决定了操作系统如何将页面写入磁盘。当然，它们可以简单地一次写出一个。然而，许多系统会在内存中收集一些待完成写入，并以一种（更高效）的写入方式将
它们写入硬盘。这种行为通常称为聚集（clustering）写入，或者就是分组写入（grouping），这样做有效是因为硬盘驱动器的性质，执行单次大的写操作，比许多小的写操作更有效。