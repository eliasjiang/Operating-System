## 锁的基本思想

锁就是一个变量，因此我们需要声明一个某种类型的锁变量（lock  variable，如上面的mutex），才能使用。这个锁变量（简称锁）保存了锁在某一时刻的状态。它要么是可用的（available，或unlocked，或free），表示没有线程持有锁，要么是被占用的（acquired，或locked，或held），表示有一个线程持有锁，正处于临界区。我们也可以保存其他的信息，比如持有锁的线程，或请求获取锁的线程队列，但这些信息会隐藏起来，锁的使用者不会发现。

##  Pthread 锁

## 实现一个锁

## 评价锁
第一是锁是否能完成它的基本任务，即提供互斥（mutual  exclusion）。最基本的，锁是否有效，能够阻止多个线程进入临界区？ 
第二是公平性（fairness）。当锁可用时，是否每一个竞争线程有公平的机会抢到锁？用另一个方式来看这个问题是检查更极端的情况：是否有竞争锁的线程会饿死（starve），一直无法获得锁？
最后是性能（performance），具体来说，是使用锁之后增加的时间开销。有几种场景需
要考虑。一种是没有竞争的情况，即只有一个线程抢锁、释放锁的开支如何？另外一种是
一个CPU 上多个线程竞争，性能如何？最后一种是多个CPU、多个线程竞争时的性能。

## 控制中断
最早提供的互斥解决方案之一，就是在临界区关闭中断。这个解决方案是为单处理器
系统开发的。假设我们运行在这样一个单处理器系统上。通过在进入临界区之前关闭中断（使用特殊的硬件指令），可以保证临界区的代码不会被中断，从而原子地执行。结束之后，我们重新打开中断（同样通过硬件指令），程序正常运行。

这个方法的主要优点就是简单。显然不需要费力思考就能弄清楚它为什么能工作。没
有中断，线程可以确信它的代码会继续执行下去，不会被其他线程干扰。

遗憾的是，缺点很多。首先，这种方法要求我们允许所有调用线程执行特权操作（打
开关闭中断），即信任这种机制不会被滥用。

第一，一个贪婪的程序可能在它开始时就调用 lock()，从而独占处理器。更糟的情况是，恶意程序调用 lock()后，一直死循环。后一种情况，系统无法重新获得控制，只能重启系统。关闭中断对应用要求太多，不太适合作为通用的同步解决方案。 

第二，这种方案不支持多处理器。如果多个线程运行在不同的CPU 上，每个线程都试
图进入同一个临界区，关闭中断也没有作用。线程可以运行在其他处理器上，因此能够进
入临界区。多处理器已经很普遍了，我们的通用解决方案需要更好一些。 

第三，关闭中断导致中断丢失，可能会导致严重的系统问题。假如磁盘设备完成了读
取请求，但CPU 错失了这一事实，那么，操作系统如何知道去唤醒等待读取的进程？ 

最后一个不太重要的原因就是效率低。与正常指令执行相比，现代CPU 对于关闭和打
开中断的代码执行得较慢。

## 测试并设置指令（原子交换）
最简单的硬件支持是测试并设置指令（test-and-set instruction），也叫作原子交换（atomic exchange）。

## 实现可用的自旋锁

## 评价自旋锁
锁最重要的一点是正确性（correctness）：
能够互斥吗？答案是可以的：自旋锁一次只允许一个线程进入临界区。因此，这是正确的锁。 

下一个标准是公平性（fairness）。自旋锁对于等待线程的公平性如何呢？能够保证一个
等待线程会进入临界区吗？答案是自旋锁不提供任何公平性保证。实际上，自旋的线程在
竞争条件下可能会永远自旋。自旋锁没有公平性，可能会导致饿死。 

最后一个标准是性能（performance）。使用自旋锁的成本是多少？为了更小心地分析，
我们建议考虑几种不同的情况。首先，考虑线程在单处理器上竞争锁的情况。然后，考虑
这些线程跨多个处理器。

对于自旋锁，在单CPU 的情况下，性能开销相当大。假设一个线程持有锁进入临界区
时被抢占。调度器可能会运行其他每一个线程（假设有N−1 个这种线程）。而其他线程都在竞争锁，都会在放弃CPU 之前，自旋一个时间片，浪费CPU 周期。 

但是，在多CPU 上，自旋锁性能不错（如果线程数大致等于CPU 数）。假设线程A 在
CPU 1，线程 B 在CPU 2 竞争同一个锁。线程A（CPU 1）占有锁时，线程B 竞争锁就会自旋（在 CPU 2 上）。然而，临界区一般都很短，因此很快锁就可用，然后线程B 获得锁。自旋等待其他处理器上的锁，并没有浪费很多CPU 周期，因此效果不错。

##  比较并交换